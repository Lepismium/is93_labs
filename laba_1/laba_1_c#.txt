using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BitOperations
{
    class Program
    {
        //главная программа
        static void Main(string[] args)
        {
            //задача #1
            int v1 = -24,
                v2 = 128,
                v3 = 13;

            Console.WriteLine("===================================================================");
            Console.WriteLine("                           Задача 1");
            Console.WriteLine("Уменьшение на единицу числа: "+v1);
            func1(ref v1);
            Console.WriteLine("Результат: " + v1);
            Console.WriteLine("Уменьшение на единицу числа: " + v2);
            func1(ref v2);
            Console.WriteLine("Результат: " + v2);
            Console.WriteLine("Уменьшение на единицу числа: " + v3);
            func1(ref v3);
            Console.WriteLine("Результат: " + v3);


            //задача #2
            int v11 = 0,
                v12 = 36,
                v13 = 16,
                v21 = -7,
                v22 = 136,
                v23 = 16;

            Console.WriteLine("===================================================================");
            Console.WriteLine("                           Задача 2");

            //проверка первой пары чисел
            Console.WriteLine("Проверка условия: " + v11 + " < " + v21);

            if (func2(v11, v21) == 1)
                Console.WriteLine("Результат отношения - ИСТИНА");
            else
                Console.WriteLine("Результат отношения - ЛОЖЬ");

            //проверка второй пары чисел
            Console.WriteLine("Проверка условия: " + v12 + " < " + v22);
            if (func2(v12, v22) == 1)
                Console.WriteLine("Результат отношения - ИСТИНА");
            else
                Console.WriteLine("Результат отношения - ЛОЖЬ");

            //проверка третьей пары чисел
            Console.WriteLine("Проверка условия: " + v13 + " < " + v23);
            if (func2(v13, v23) == 1)
                Console.WriteLine("Результат отношения - ИСТИНА");
            else
                Console.WriteLine("Результат отношения - ЛОЖЬ");
            Console.ReadKey();
        }
        //*******************************************************************************
        //Написати функції на мовах C++ та C#, які моделюють на бітовому рівні
        //операції згідно з варіантом. Для перевірки вірності роботи програм використати
        //значення з варіанта. Перша функція завдання повертає результат через
        //параметр, друга - оператором return.
        //*******************************************************************************

        //счетчик уменьшения на единицу
        //значения для проверки: -24, 128, 13
        //предполагается, что обрабатывается число размером в 1 байт, то есть величиной до 255

        //функция 1. Уменьшение на единицу. возвращает значение через параметр
        //функция возвращает значение через параметр
        static void func1(ref int d)
        {
            int tmp;

            //получить самый младший бит
            tmp = d & 0x01;

            //инвертируем младший бит в любом случае
            d = d ^ 1; //операция d xor 00000001	

            if (tmp == 1)
                return; //если младший бит был равен 1, то заканчиваем функцию
            else //если младший бит был равен 0, то
                 //двигаемся от младших битов (от номера 1) к старшим, пока не встретим бит, равный 1
            {
                int i = 1;         //счетчик битов
                int mask; //маска

                mask = 0x02;       //начальное значение маски "00000010"
                                   //начиная с номера 1, двигаемся влево
                while ((d & mask) == 0)    //пока текущие биты числа - 0, продолжаем цикл
                {
                    d = d ^ mask;      //инвертируем текущий бит
                    i++;               //увеличиваем номер бита
                    if (i == 8) return; //проверка на случай, если бит равный 1 так и не встретится. Закончить функцию
                    mask = mask << 1;  //получаем новую маску сдвигом бита на одну позицию влево
                }                      //переходим к следующему (старшему) биту

                d = d ^ mask;              //инвертируем текущий бит, равный 1
            }
        }

        //-----------------------------------------------------------------------------------------
        //функция 2. Проверка отношения меньше - "<"
        //функция возвращает результат операции сравнения "<" между заданными операндами i1 и i2
        //если операция сравнения истинна, то возвращается 1, в противном случае возвращается 0
        //функция возвращает значение через оператор return
        static int func2(int i1, int i2)
        {
            int tmp1, tmp2;
            int mask;

            //проверка на отрицательность
            //если одно из чисел отрицательное, то оно всегда меньше положительного
            mask = 1;
            mask = mask << 15; //получить маску самого левого бита. Считаем число 2-х байтовым (для простоты)
            tmp1 = i1 & mask;  //получить знак первого числа
            tmp2 = i2 & mask;  //получить знак второго числа

            //если первое число отрицательное, а второе положительное, то первое число меньше
            if (((tmp1 >> 15) == 1) && ((tmp2 >> 15) == 0))
                return 1;   //результат ИСТИНА

            //если второе число отрицательное, а первое положительное, то второе число меньше
            if (((tmp1 >> 15) == 0) && ((tmp2 >> 15) == 1))
                return 0;

            //если оба числа положительные, то
            //ведем проверку битов обоих чисел слева направо
            //для простоты считаем, что числа 16-разрядные
            mask = 1;
            mask = mask << 15;
            while (mask > 0) //пока биты не закончились продолжать цикл
            {

                tmp1 = i1 & mask;  //получить текущий бит первого числа
                tmp2 = i2 & mask;  //получить текущий бит второго числа

                //если у первого числа есть бит, а у второго - нет, то первое число больше второго 
                if ((tmp1 != 0) && (tmp2 == 0))
                    return 0; //результат ЛОЖЬ

                //если у второго числа есть бит, а у первого - нет, то второе число больше первого (первое меньше второго)
                if ((tmp1 == 0) && (tmp2 != 0))
                    return 1;  //результат ИСТИНА

                mask = mask >> 1; //сдвигаем маску на один бит вправо			
            }

            //если произошел нормальный проход всего цикла, то значит числа равны
            //результат операции "<" равен ЛОЖЬ
            return 0;
        }


    }
}